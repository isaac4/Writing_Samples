Parameterized classes are still pretty [-new — they was-] {+new. They were+} only added to Puppet in version [-2.6.0 —, and-] {+2.6.0. Yet+} they {+have+} changed the landscape of [-puppet-] {+Puppet+} in [-some-] ways that aren't [-immediatly-] {+immediately+} obvious. 

You probably [-notice-] {+have noticed+} that the examples {+in+} this [-chapter, are all using-] {+chapter use+} the resource-like declaration syntax instead of the include function. [-Thats-] {+That's+} because include doesn't work with parameterized classes, and likely never will. The problem is [-than-] {+that+} the whole point of include conflicts with the idea that a class can change depending on how its [-declared — if-] {+declared. If+} you declare a [-Class-] {+class+} multiple times and the attributes don't match precisely, which set of attributes wins? 

Parameterized classes made the problem with that [-paradime-] {+paradigm+} more explicit, but it already [-existed, and it-] {+existed. It+} was possible to run afoul of [-them-] {+it+} without even [-noticeing.-] {+noticing.+} A common pattern for passing information into a class was to choose an external variable and have the class [-retrieval-] {+retrieve+} it with dynamically-scoped variable [-lookup-] {+lookup.+} If [-you're-] {+you+} were also having low-level classes manage their own dependencies by including anything they might [-needs,-] {+need+} than a given class might have several potential scope chains resolving to different [-values, which-] {+values. This+} would result in a [-race —-] {+race:+} whichever include took effect first would determined the [-behaviour-] {+behavior+} of the class. 

