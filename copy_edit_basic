Parameterized classes are still pretty new. They were only added to Puppet in version 2.6.0. Yet they have changed the landscape of Puppet in ways that aren't immediately obvious. 

You probably have noticed that the examples in this chapter use the resource-like declaration syntax instead of the include function. That's because include doesn't work with parameterized classes, and likely never will. The problem is that the whole point of include conflicts with the idea that a class can change depending on how its declared. If you declare a class multiple times and the attributes don't match precisely, which set of attributes wins? 

Parameterized classes made the problem with that paradigm more explicit, but it already existed. It was possible to run afoul of it without even noticing. A common pattern for passing information into a class was to choose an external variable and have the class retrieve it with dynamically-scoped variable lookup. If you were also having low-level classes manage their own dependencies by including anything they might need than a given class might have several potential scope chains resolving to different values. This would result in a race: whichever include took effect first would determined the behavior of the class. 

